system prompt: you are a professional principal level postgres engineer. you create bug-free code that meets the expectations of the code requirements given to you.
I have a database with 1 table in it with the following schema:
                                Table "public.content"

                                 Table "public.content"
    Column    |            Type             | Collation | Nullable |      Default       
--------------+-----------------------------+-----------+----------+--------------------
 id           | uuid                        |           | not null | uuid_generate_v4()
 created_at   | timestamp without time zone |           |          | now()
 updated_at   | timestamp without time zone |           |          | now()
 content_type | text                        |           | not null | 
 content      | jsonb                       |           |          | 
 manifest     | jsonb                       |           |          | 
Indexes:
    "content_pkey" PRIMARY KEY, btree (id)


Please write a CTE that will gather all dependent ids from the queried record on insert or update and update the queried record's manifest column with the dependent ids. the keys for the dependent ids vary, so use the %_model wildcard to match keys. Please wrap the resulting CTE in a stored procedure.
queried record: id = '66db1504-62bd-49d2-9e13-9f7965176c80', content = '{"id": "66db1504-62bd-49d2-9e13-9f7965176c80", "disposition": "d7c9d185-7c31-4180-b09c-259c86a9c948", "prompt":"e15d7c4f-3155-4946-9cd0-ca08cbcdbf50"}'
dependant records:
id = 'd7c9d185-7c31-4180-b09c-259c86a9c948', content = '{"id":"d7c9d185-7c31-4180-b09c-259c86a9c948", "entitlements":"0dc2cc8a-4c32-41ae-8a20-a794381bb9e8"}'
id = '0dc2cc8a-4c32-41ae-8a20-a794381bb9e8', content = '{"id":"0dc2cc8a-4c32-41ae-8a20-a794381bb9e8", "nodes:[\"f3d917ee-c6c2-4a1d-bb0a-72b837717b70\",\"5fdeefbf-7100-49ba-b1bd-84618cb2f011\"]}'
id = 'f3d917ee-c6c2-4a1d-bb0a-72b837717b70', content = '{"id":"f3d917ee-c6c2-4a1d-bb0a-72b837717b70", "min_length":"1"}'
id = '5fdeefbf-7100-49ba-b1bd-84618cb2f011', content = '{"id":"5fdeefbf-7100-49ba-b1bd-84618cb2f011", "max_length":"2"}'
id = 'e15d7c4f-3155-4946-9cd0-ca08cbcdbf50', content = '{"id":"e15d7c4f-3155-4946-9cd0-ca08cbcdbf50", "ad_length":"3"}'

the manifest column may or may not be populated with the dependent id's of that record.

the query should update the queried record's manifest column with a json string array of:
 ["66db1504-62bd-49d2-9e13-9f7965176c80",
 "d7c9d185-7c31-4180-b09c-259c86a9c948",
 "0dc2cc8a-4c32-41ae-8a20-a794381bb9e8",
 "f3d917ee-c6c2-4a1d-bb0a-72b837717b70",
 "5fdeefbf-7100-49ba-b1bd-84618cb2f011",
 "e15d7c4f-3155-4946-9cd0-ca08cbcdbf50"]


CREATE OR REPLACE FUNCTION update_manifest_with_dependencies(target_id UUID)
RETURNS VOID AS
$$
WITH RECURSIVE dependency_cte AS (
    -- Seed with the initial record
    SELECT 
        c.id,
        c.content,
        ARRAY[c.id] AS dependent_ids
    FROM public.content c
    WHERE c.id = target_id

    UNION ALL

    -- Recursive: find dependencies from 'disposition', 'entitlements', and 'nodes'
    SELECT
        c.id,
        c.content,
        dep.dependent_ids || c.id
    FROM public.content c
    JOIN dependency_cte dep ON (
        -- Match 'disposition' with previous IDs
        c.content ->> 'disposition' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'entitlements' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'verification' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'bypass' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'youtube' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'tiktok' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'rumble' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'facebook' = ANY(dep.dependent_ids)
        OR
        c.content ->> 'patreon' = ANY(dep.dependent_ids)
        -- Match 'nodes' array with previous IDs
        -- ((c.content -> 'nodes')::jsonb ?| array_agg(dep.id))
    )
),
expanded_ids AS (
    -- Extract all distinct IDs from the dependency list
    SELECT DISTINCT unnest(dep.dependent_ids) AS id
    FROM dependency_cte dep
)
-- Update the target record's manifest
UPDATE public.content
SET manifest = (
    SELECT COALESCE(ARRAY_TO_JSON(array_agg(DISTINCT id)), '[]'::jsonb)
    FROM expanded_ids
)
WHERE id = target_id;
$$ LANGUAGE SQL;


CREATE OR REPLACE FUNCTION update_manifest_with_dependencies(target_id UUID)
RETURNS VOID AS
$$
WITH RECURSIVE dependency_cte AS (
    -- Initial selection: start with the given id
    SELECT id, content
    FROM content
    WHERE id = target_id

    UNION ALL

    -- Recursive selection: find records whose id is in the content of the previous records
    SELECT c.id, c.content
    FROM content c
    JOIN dependent_ids d ON 
        c.id::text = ANY(
            jsonb_array_elements_text(jsonb_extract_path(d.content, 'nodes')) || 
            array_agg(key)
        )
    WHERE c.id <> d.id
),
-- Collect all distinct ids from the recursive CTE
collected_ids AS (
    SELECT DISTINCT id AS dependent_id
    FROM dependent_ids
),
-- Extract keys matching the pattern %_model and their values
matching_keys AS (
    SELECT key, value::text AS uuid_value
    FROM content, jsonb_each(content)
    WHERE id = target_id
      AND key LIKE '%_model'
),
-- Combine initial ids with matching keys
combined_ids AS (
    SELECT DISTINCT dependent_id
    FROM collected_ids

    UNION ALL

    SELECT uuid_value::uuid
    FROM matching_keys
)
-- Update the manifest column of the queried record with the combined dependent ids
UPDATE content
SET manifest = (
    SELECT jsonb_agg(dependent_id::text) 
    FROM combined_ids
)
WHERE id = target_id;
$$ LANGUAGE SQL;
